##################################################
### FILE: ./install-smtp/lib/json_builder.sh
##################################################

# lib/json_builder.sh — минимальный билдер JSON без внешних зависимостей.
# Глобальные переменные: __JSON, __FIRST

# Экранирование для строк JSON (достаточно для наших данных)
json_escape() {
  # заменяем \, ", и управляющие \n \r \t
  local s="$1"
  s="${s//\\/\\\\}"
  s="${s//\"/\\\"}"
  s="${s//$'\n'/\\n}"
  s="${s//$'\r'/\\r}"
  s="${s//$'\t'/\\t}"
  printf '%s' "$s"
}

json_begin() { __JSON="{"; __FIRST=1; }

# низкоуровневый: добавить пару "key":<raw>
json_add_kv_raw() {
  local key="$1" raw="$2"
  if [[ "${__FIRST}" -eq 0 ]]; then __JSON+=","
  else __FIRST=0; fi
  __JSON+="\"$(json_escape "$key")\":${raw}"
}

json_add_string() {
  local key="$1" val="$2"
  json_add_kv_raw "$key" "\"$(json_escape "$val")\""
}

json_add_object() {
  local key="$1" obj="$2"
  json_add_kv_raw "$key" "${obj}"
}

json_add_array_strings() {
  local key="$1"; shift
  local out="[" first=1 x
  for x in "$@"; do
    if [[ $first -eq 0 ]]; then out+=","
    else first=0; fi
    out+="\"$(json_escape "$x")\""
  done
  out+="]"
  json_add_kv_raw "$key" "$out"
}

json_end() { __JSON+="}"; printf '%s' "$__JSON"; }


##################################################
### FILE: ./install-smtp/lib/common.sh
##################################################

# lib/common.sh — общие хелперы
# shellcheck shell=bash
set -Eeuo pipefail
IFS=$'\n\t'

_ts() { date -u +"%Y-%m-%dT%H:%M:%SZ"; }

log_info()  { printf '[%s] [INFO]  %s\n'  "$(_ts)" "$*" >&2; }
log_warn()  { printf '[%s] [WARN]  %s\n'  "$(_ts)" "$*" >&2; }
log_error() { printf '[%s] [ERROR] %s\n'  "$(_ts)" "$*" >&2; }

die() {
  local code=1
  if [[ $# -ge 1 && "$1" =~ ^[0-9]+$ ]]; then code="$1"; shift; fi
  log_error "$*"
  exit "${code}"
}

# Безопасное выполнение команд с уважением к DRY_RUN.
# Поведение:
# - Если передана одна строка — исполняем через bash -c (для пайпов и т.п.).
# - Если передано несколько аргументов:
#     * Если в начале идут присваивания вида KEY=VALUE — исполняем через /usr/bin/env KEY=VALUE cmd args...
#     * Иначе — исполняем напрямую без шелла.
run_cmd() {
  if [[ "${DRY_RUN:-false}" == "true" ]]; then
    log_info "DRY-RUN: $*"
    return 0
  fi

  # Несколько аргументов → прямая exec с поддержкой префиксных VAR=VAL
  if [[ $# -gt 1 ]]; then
    local -a argv=( "$@" )
    local i=0
    # Ищем ведущие присваивания окружения KEY=VALUE
    while (( i < ${#argv[@]} )); do
      # Разрешаем только корректные имена переменных окружения
      if [[ "${argv[$i]}" =~ ^[A-Za-z_][A-Za-z0-9_]*= ]]; then
        ((i++))
        continue
      fi
      break
    done

    if (( i > 0 )); then
      # Есть хотя бы одно присваивание окружения → запускаем через env
      log_info "RUN: env ${argv[*]}"
      /usr/bin/env "${argv[@]}"
    else
      log_info "RUN: ${argv[*]}"
      "${argv[@]}"
    fi
    return
  fi

  # Один аргумент — строка (нужен шелл для пайпов/редиректов)
  local cmd="$*"
  log_info "RUN: $cmd"
  /bin/bash -o pipefail -c "$cmd"
}

ensure_root_or_die() {
  if [[ "${EUID}" -ne 0 ]]; then
    die 1 "Нужны root-привилегии (sudo) для режима установки"
  fi
}

require_cmd() {
  local c="$1"
  command -v "$c" >/dev/null 2>&1 || die 1 "Не найден бинарь: $c"
}


##################################################
### FILE: ./install-smtp/install.sh
##################################################

#!/usr/bin/env bash
set -euo pipefail

# --- раннее логирование во встроенный файл + на экран ---
LOG_DIR="/var/log/msa"
mkdir -p "${LOG_DIR}"
export LOG_FILE="${LOG_DIR}/install-$(date -u +%Y%m%d-%H%M%S).log"
# Дублируем stdout/stderr и в файл, и на экран
exec > >(tee -a "${LOG_FILE}") 2>&1

# --- bootstrap logger used до загрузки общих хелперов ---
if [[ "$(type -t log 2>/dev/null)" != "function" ]]; then
  log(){ printf '[%(%FT%TZ)T] [%s] %s\n' -1 "${1:-INFO}" "${*:2}"; }
fi
if [[ "$(type -t run 2>/dev/null)" != "function" ]]; then
  run(){ log INFO "RUN: $*"; "$@"; }
fi
# --- конец бутстрапа ---

# --- paths --------------------------------------------------------------------
SCRIPT_DIR="$(cd -- "$(dirname "${BASH_SOURCE[0]}")" >/dev/null 2>&1 && pwd)"
MODULES_DIR="${SCRIPT_DIR}/modules"
LIB_DIR="${SCRIPT_DIR}/lib"

# --- libs ---------------------------------------------------------------------
# shellcheck disable=SC1090
source "${LIB_DIR}/common.sh"   # die, run_cmd, require_cmd, log_*

# --- globals ------------------------------------------------------------------
VARS_FILE=""
MODE="install"        # install | healthcheck | print-dns
DRY_RUN=false

# --- utils --------------------------------------------------------------------
require_yq_v4() {
  require_cmd yq
  local out major
  out="$(yq -V 2>&1 || true)"
  major="$(grep -oE '[0-9]+' <<<"$out" | head -n1 || true)"
  if [[ -z "${major:-}" || "${major}" -lt 4 ]]; then
    die "Нужен yq v4+, найдено: ${out:-unknown}"
  fi
}

ensure_root_if_needed() {
  if [[ "${DRY_RUN}" == "false" && "${EUID}" -ne 0 ]]; then
    die "Нужны root-привилегии (sudo) для режима установки"
  fi
}

# ===== ensure yq v4+ (автоустановка при необходимости) =====
ensure_yq_v4() {
  _log(){ printf '[%(%FT%TZ)T] [%s] %s\n' -1 "${1:-INFO}" "${*:2}"; }

  local need_major=4 cur="" major=""
  if command -v yq >/dev/null 2>&1; then
    cur="$(yq --version 2>/dev/null || true)"   # e.g. "yq (...) version v4.47.1"
    major="$(printf '%s\n' "$cur" | sed -n 's/.*version v\{0,1\}\([0-9]\+\).*/\1/p')"
    if [[ -n "$major" && "$major" -ge "$need_major" ]]; then
      _log INFO "yq найден: ${cur}"
      return 0
    fi
    _log WARN "нужен yq v4+, найдено: ${cur:-unknown} — обновляю бинарник"
  else
    _log INFO "yq не найден — ставлю свежий v4"
  fi

  if ! command -v wget >/dev/null 2>&1 && ! command -v curl >/dev/null 2>&1; then
    _log INFO "ставлю wget для загрузки yq…"
    apt-get update -y >/dev/null 2>&1 || true
    DEBIAN_FRONTEND=noninteractive apt-get -y install wget ca-certificates >/dev/null 2>&1 || true
  fi

  local url="https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64"
  if command -v wget >/dev/null 2>&1; then
    wget -q "$url" -O /usr/local/bin/yq
  else
    curl -fsSL "$url" -o /usr/local/bin/yq
  fi
  chmod +x /usr/local/bin/yq || true

  local newver; newver="$(yq --version 2>/dev/null || true)"
  if ! grep -q 'version v4' <<<"$newver"; then
    _log ERROR "не удалось установить yq v4 (текущее: ${newver})"
    exit 1
  fi
  _log INFO "yq установлен: ${newver}"
}

ensure_yq_v4

usage() {
  printf '%s\n' \
"usage: $0 --vars vars.yaml [--dry-run] [--healthcheck] [--print-dns]
  --vars FILE      путь к vars.yaml (обязателен для install/print-dns)
  --dry-run        не выполнять изменяющие команды
  --healthcheck    запустить только 99_healthcheck.sh
  --print-dns      вывести DNS-записи (A/MX/SPF/DKIM/DMARC)
  -h, --help       показать эту справку"
}

parse_args() {
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --vars|-f)
        [[ $# -ge 2 ]] || die "--vars требует путь к файлу"
        VARS_FILE="$2"; shift 2;;
      --dry-run)
        DRY_RUN=true; shift;;
      --healthcheck|-m)
        # Совместимость: -m healthcheck
        if [[ "$1" == "-m" ]]; then
          [[ $# -ge 2 ]] || die "-m требует значение (install|healthcheck|print-dns)"
          MODE="$2"; shift 2
        else
          MODE="healthcheck"; shift
        fi
        ;;
      --print-dns)
        MODE="print-dns"; shift;;
      -h|--help)
        usage; exit 0;;
      *)
        die "Неизвестный аргумент: $1";;
    esac
  done
  if [[ -z "${VARS_FILE}" && "${MODE}" != "healthcheck" ]]; then
    die "Укажите --vars <file>"
  fi
}

load_and_validate_vars() {
  require_yq_v4
  [[ -r "${VARS_FILE}" ]] || die "vars.yaml не найден: ${VARS_FILE}"

  export DOMAIN HOSTNAME IPV4 ACCEPT_INBOUND ACME_EMAIL DKIM_SELECTOR

  DOMAIN="$(yq -r '.domain // ""' "${VARS_FILE}")"
  HOSTNAME="$(yq -r ".hostname // (\"mail.\" + .domain)" "${VARS_FILE}")"
  IPV4="$(yq -r '.ipv4 // ""' "${VARS_FILE}")"
  ACME_EMAIL="$(yq -r ".acme_email // (\"postmaster@\" + .domain)" "${VARS_FILE}")"
  DKIM_SELECTOR="$(yq -r ".dkim_selector // \"s1\"" "${VARS_FILE}")"

  # accept_inbound: явный флаг имеет приоритет; иначе — по mode (default full_mail)
  if yq -e '.accept_inbound' "${VARS_FILE}" >/dev/null 2>&1; then
    ACCEPT_INBOUND="$(yq -r '.accept_inbound' "${VARS_FILE}")"
  else
    MODE_MAIL="$(yq -r '.mode // "full_mail"' "${VARS_FILE}")"
    if [[ "${MODE_MAIL}" == "outbound_only" ]]; then
      ACCEPT_INBOUND="false"
    else
      ACCEPT_INBOUND="true"
    fi
  fi

  local users_count
  users_count="$(yq -r '.users // [] | length' "${VARS_FILE}")"

  [[ -n "${DOMAIN}"   ]] || die "В vars.yaml отсутствует domain"
  [[ -n "${HOSTNAME}" ]] || die "В vars.yaml отсутствует hostname/логика подстановки"
  [[ -n "${IPV4}"    ]] || die "В vars.yaml отсутствует ipv4"
  [[ "${users_count}" -ge 1 ]] || die "В vars.yaml нет пользователей (.users)"

  if ! grep -qE '^[0-9]{1,3}(\.[0-9]{1,3}){3}$' <<<"${IPV4}"; then
    die "Неверный формат IPv4: ${IPV4}"
  fi

  log_info "vars.yaml ок: domain=${DOMAIN}, hostname=${HOSTNAME}, ipv4=${IPV4}, users=${users_count}, mode=${MODE}, accept_inbound=${ACCEPT_INBOUND}, dry_run=${DRY_RUN}"
}

# --- module loader ------------------------------------------------------------
source_modules_install() {
  # Загрузим ВСЕ модули вида NN_name.sh (включая 100_report.sh и т.д.) по возрастанию
  while IFS= read -r -d '' mod; do
    log_info "Загружаю модуль: $(basename "$mod")"
    # shellcheck disable=SC1090
    source "$mod"
  done < <(find "${MODULES_DIR}" -maxdepth 1 -type f -name '[0-9]*_*.sh' -print0 | sort -z -V)
}

source_module_healthcheck_only() {
  local hc="${MODULES_DIR}/99_healthcheck.sh"
  [[ -f "${hc}" ]] || die "Не найден modules/99_healthcheck.sh"
  log_info "Загружаю модуль: 99_healthcheck.sh"
  # shellcheck disable=SC1090
  source "${hc}"
}

# --- manifest builder (встроенный) --------------------------------------------
json_escape() {
  local s="${1:-}"
  s="${s//\\/\\\\}"; s="${s//\"/\\\"}"
  s="${s//$'\n'/\\n}"; s="${s//$'\r'/\\r}"
  printf '%s' "$s"
}

emit_manifest() {
  local ports_json le_json dns_json auth_json hc_json

  # ports (собираем PORT_*)
  ports_json="{"
  local first=true
  while IFS='=' read -r k v; do
    local port="${k#PORT_}"
    $first || ports_json+=","
    first=false
    ports_json+="\"${port}\":\"$(json_escape "${v}")\""
  done < <(env | grep -E '^PORT_[0-9]+=' || true)
  ports_json+="}"

  # le
  le_json="{\"domain\":\"$(json_escape "${HOSTNAME}")\""
  if [[ -n "${LE_VALID_UNTIL:-}" ]]; then
    le_json+=",\"valid_until\":\"$(json_escape "${LE_VALID_UNTIL}")\""
  fi
  le_json+="}"

  # dns
  local dkim_selector="${DKIM_SELECTOR:-s1}"
  local dkim_txt="${DKIM_DNS_TXT:-}"
  local dmarc_txt="${DMARC_TXT:-v=DMARC1; p=none; rua=mailto:dmarc@${DOMAIN}}"

  dns_json="{"
  dns_json+="\"selector\":\"$(json_escape "${dkim_selector}")\""
  if [[ -n "${dkim_txt}" ]]; then
    dns_json+=",\"txt\":\"$(json_escape "${dkim_txt}")\""
  fi
  dns_json+=",\"DMARC\":\"$(json_escape "${dmarc_txt}")\""
  if [[ -n "${dkim_txt}" ]]; then
    dns_json+=",\"DKIM\":{\"selector\":\"$(json_escape "${dkim_selector}")\",\"txt\":\"$(json_escape "${dkim_txt}")\"}"
  fi
  dns_json+="}"

  # auth (логины из vars.yaml)
  local logins
  mapfile -t logins < <(yq -r '.users[]?.login // empty' "${VARS_FILE}")
  auth_json="["
  for i in "${!logins[@]}"; do
    [[ $i -gt 0 ]] && auth_json+=","
    # нормализуем как user@DOMAIN
    if [[ "${logins[$i]}" == *"@"* ]]; then
      auth_json+="\"$(json_escape "${logins[$i]}")\""
    else
      auth_json+="\"$(json_escape "${logins[$i]}@${DOMAIN}")\""
    fi
  done
  auth_json+="]"

  # healthcheck (HC_* из env)
  hc_json="{"
  first=true
  while IFS='=' read -r k v; do
    $first || hc_json+=","
    first=false
    hc_json+="\"$(json_escape "${k#HC_}")\":\"$(json_escape "${v}")\""
  done < <(env | grep -E '^HC_' || true)
  hc_json+="}"

  local manifest
  manifest="{"
  manifest+="\"hostname\":\"$(json_escape "${HOSTNAME}")\","
  manifest+="\"ipv4\":\"$(json_escape "${IPV4}")\","
  manifest+="\"ports\":${ports_json},"
  manifest+="\"le\":${le_json},"
  manifest+="\"dns\":${dns_json},"
  manifest+="\"auth\":{\"users_created\":${auth_json}},"
  manifest+="\"healthcheck\":${hc_json}"
  manifest+="}"

  run_cmd "install -d -m 0755 /var/local/msa"
  local tmp; tmp="$(mktemp)"
  printf '%s\n' "${manifest}" > "${tmp}"
  run_cmd "install -m 0644 '${tmp}' /var/local/msa/manifest.json"
  rm -f "${tmp}"
  log_info "manifest.json записан в /var/local/msa/manifest.json"
  printf '%s\n' "${manifest}"
}
# (блок emit_manifest основан на твоём текущем инсталлере). :contentReference[oaicite:2]{index=2}

# --- extra modes --------------------------------------------------------------
run_print_dns() {
  echo "=== DNS records to add for ${DOMAIN} / ${HOSTNAME} ==="
  echo
  echo "A     ${HOSTNAME}.      ${IPV4}"
  echo "MX    ${DOMAIN}.        10 ${HOSTNAME}."
  echo "TXT   ${DOMAIN}.        v=spf1 mx -all"
  local dkim_selector="${DKIM_SELECTOR:-s1}"
  if [[ -n "${DKIM_DNS_TXT:-}" ]]; then
    echo "TXT   ${dkim_selector}._domainkey.${DOMAIN}.  ${DKIM_DNS_TXT}"
  else
    echo "TXT   ${dkim_selector}._domainkey.${DOMAIN}.  (после генерации ключа)"
  fi
  echo "TXT   _dmarc.${DOMAIN}.  ${DMARC_TXT:-v=DMARC1; p=none; rua=mailto:dmarc@${DOMAIN}}"
  echo
}

# --- modes --------------------------------------------------------------------
run_install() {
  ensure_root_if_needed
  echo "Starting installation for domain ${DOMAIN} (hostname ${HOSTNAME}, ipv4 ${IPV4})..."
  source_modules_install
  emit_manifest
}

run_healthcheck() {
  source_module_healthcheck_only
  if declare -F healthcheck::run_all >/dev/null 2>&1; then
    healthcheck::run_all || true
  else
    die "В 99_healthcheck.sh нет функции healthcheck::run_all"
  fi
}

# --- main ---------------------------------------------------------------------
main() {
  parse_args "$@"

  if [[ "${MODE}" != "healthcheck" ]]; then
    load_and_validate_vars
  else
    log_info "mode=healthcheck"
  fi

  case "${MODE}" in
    install)      run_install ;;
    healthcheck)  run_healthcheck ;;
    print-dns)    run_print_dns ;;
    *)            die "Неизвестный режим: ${MODE}" ;;
  esac
}

main "$@"


##################################################
### FILE: ./install-smtp/modules/06_ssl.sh
##################################################

#!/usr/bin/env bash
# modules/06_ssl.sh — выпуск LE-сертификата + хуки обновления + финализация Dovecot и Postfix (587/465)
set -Eeuo pipefail
IFS=$'\n\t'

ssl::le_paths() {
  LE_DIR="/etc/letsencrypt/live/${HOSTNAME}"
  LE_FULL="${LE_DIR}/fullchain.pem"
  LE_KEY="${LE_DIR}/privkey.pem"
}

ssl::obtain_cert() {
  ssl::le_paths
  if [[ -r "${LE_FULL}" && -r "${LE_KEY}" ]]; then
    log_info "LE: сертификат для ${HOSTNAME} уже существует — пропускаю выпуск"
    return 0
  fi

  local email="${ACME_EMAIL:-postmaster@${DOMAIN}}"
  log_info "LE: запрашиваю сертификат для ${HOSTNAME}"
  run_cmd certbot certonly --standalone \
    --preferred-challenges http \
    --non-interactive --agree-tos --no-eff-email \
    -m "${email}" -d "${HOSTNAME}"
}

ssl::setup_renew_hooks() {
  ssl::le_paths
  local hook_dir="/etc/letsencrypt/renewal-hooks/deploy"
  local hook="${hook_dir}/99-reload-mail-services.sh"

  log_info "LE: настраиваю deploy-hook для перезагрузки Postfix/Dovecot"
  local tmp_hook; tmp_hook="$(mktemp)"
  cat > "${tmp_hook}" <<'EOF'
#!/usr/bin/env bash
set -Eeuo pipefail
systemctl reload postfix 2>/dev/null || systemctl restart postfix || true
systemctl reload dovecot  2>/dev/null || systemctl restart dovecot  || true
EOF
  run_cmd install -d -m 0755 "${hook_dir}"
  run_cmd install -m 0755 "${tmp_hook}" "${hook}"
  rm -f "${tmp_hook}"
}

ssl::finalize_dovecot() {
  ssl::le_paths
  if [[ ! ( -r "${LE_FULL}" && -r "${LE_KEY}" ) ]]; then
    log_warn "Dovecot: нет LE-сертификата — пропускаю финализацию"
    return 0
  fi

  log_info "Dovecot: обнаружен LE-сертификат — включаю TLS и запускаю сервисы"
  local conf="/etc/dovecot/conf.d/90-msa.conf" tmp; tmp="$(mktemp)"
  cat > "${tmp}" <<EOF
ssl = required
ssl_cert = <${LE_FULL}
ssl_key  = <${LE_KEY}
ssl_client_ca_dir = /etc/ssl/certs
ssl_prefer_server_ciphers = yes
# Минимальная версия TLS
ssl_min_protocol = TLSv1.2

protocols = imap pop3 lmtp
mail_location = maildir:/var/vmail/%d/%n/Maildir
first_valid_uid = 100
first_valid_gid = 100
mail_privileged_group = mail

passdb {
  driver = passwd-file
  args = scheme=SHA512-CRYPT username_format=%u /etc/dovecot/passdb/users
}
userdb {
  driver = static
  args = uid=vmail gid=vmail home=/var/vmail/%d/%n
}

service auth {
  unix_listener /var/spool/postfix/private/auth {
    mode = 0660
    user = postfix
    group = postfix
  }
}
service lmtp {
  unix_listener /var/spool/postfix/private/dovecot-lmtp {
    mode = 0600
    user = postfix
    group = postfix
  }
}
EOF
  run_cmd install -D -m 0644 "${tmp}" "${conf}"
  rm -f "${tmp}"

  run_cmd systemctl enable --now dovecot
  run_cmd bash -c 'dovecot -n'
  run_cmd bash -c 'systemctl reload dovecot || systemctl restart dovecot'
}

# NEW: после появления сертификата сразу включаем submission/smtps в Postfix
ssl::finalize_postfix_ports() {
  ssl::le_paths
  if [[ ! ( -r "${LE_FULL}" && -r "${LE_KEY}" ) ]]; then
    log_warn "Postfix: LE-сертификат отсутствует — пропускаю активацию 587/465"
    return 0
  fi

  log_info "Postfix: настраиваю сервисы submission (587) и smtps (465)"
  # submission (587) — STARTTLS обязателен, AUTH включён
  run_cmd postconf -M "submission/inet= submission inet n - y - - smtpd"
  run_cmd postconf -P "submission/inet/smtpd_tls_security_level=encrypt"
  run_cmd postconf -P "submission/inet/smtpd_sasl_auth_enable=yes"
  run_cmd postconf -P "submission/inet/smtpd_client_restrictions=permit_sasl_authenticated,reject"
  run_cmd postconf -P "submission/inet/smtpd_tls_cert_file=${LE_FULL}"
  run_cmd postconf -P "submission/inet/smtpd_tls_key_file=${LE_KEY}"

  # smtps (465) — wrapper TLS, AUTH включён
  run_cmd postconf -M "smtps/inet= smtps inet n - y - - smtpd"
  run_cmd postconf -P "smtps/inet/smtpd_tls_wrappermode=yes"
  run_cmd postconf -P "smtps/inet/smtpd_sasl_auth_enable=yes"
  run_cmd postconf -P "smtps/inet/smtpd_client_restrictions=permit_sasl_authenticated,reject"
  run_cmd postconf -P "smtps/inet/smtpd_tls_cert_file=${LE_FULL}"
  run_cmd postconf -P "smtps/inet/smtpd_tls_key_file=${LE_KEY}"

  run_cmd postfix check
  run_cmd bash -c 'systemctl reload postfix || systemctl restart postfix'
}

ssl::print_cert_window() {
  ssl::le_paths
  if [[ -r "${LE_FULL}" ]]; then
    local not_before not_after
    not_before="$(openssl x509 -in "${LE_FULL}" -noout -startdate 2>/dev/null | sed 's/notBefore=//')"
    not_after="$(openssl x509 -in "${LE_FULL}" -noout -enddate   2>/dev/null | sed 's/notAfter=//')"
    log_info "LE: сертификат ${HOSTNAME} валиден с ${not_before} по ${not_after}"
  fi
}

# --- ENTRYPOINT ---
ssl::obtain_cert
ssl::setup_renew_hooks
ssl::print_cert_window
ssl::finalize_dovecot
ssl::finalize_postfix_ports


##################################################
### FILE: ./install-smtp/modules/02_firewall.sh
##################################################

# modules/02_firewall.sh — открыть нужные порты, если FW активен
# Порты: 465, 587, 993, 995, 80, и УСЛОВНО 25 (accept_inbound)
# Требует: run_cmd, log_info; переменная: ACCEPT_INBOUND
# shellcheck shell=bash

set -Eeuo pipefail
IFS=$'\n\t'

fw::open_ports() {
  local ports=(465 587 993 995 80)
  if [[ "${ACCEPT_INBOUND:-true}" == "true" ]]; then
    ports=(25 "${ports[@]}")
  else
    log_info "Firewall: accept_inbound=false — 25/tcp не открываю"
  fi

  if command -v ufw >/dev/null 2>&1 && ufw status 2>/dev/null | grep -qEi '^Status:\s+active'; then
    for p in "${ports[@]}"; do
      run_cmd "ufw allow ${p}/tcp"
    done
    log_info "Firewall: порты открыты через UFW: ${ports[*]}"
    return
  fi

  if command -v firewall-cmd >/dev/null 2>&1 && systemctl is-active --quiet firewalld; then
    # Используем сервисы, где есть
    [[ " ${ports[*]} " == *" 25 "* ]] && run_cmd "firewall-cmd --permanent --add-service=smtp"
    [[ " ${ports[*]} " == *" 587 "* ]] && run_cmd "firewall-cmd --permanent --add-service=submission" || true
    [[ " ${ports[*]} " == *" 587 "* ]] || run_cmd "firewall-cmd --permanent --add-port=587/tcp"
    [[ " ${ports[*]} " == *" 465 "* ]] && run_cmd "firewall-cmd --permanent --add-service=smtps" || run_cmd "firewall-cmd --permanent --add-port=465/tcp"
    [[ " ${ports[*]} " == *" 993 "* ]] && run_cmd "firewall-cmd --permanent --add-service=imaps" || run_cmd "firewall-cmd --permanent --add-port=993/tcp"
    [[ " ${ports[*]} " == *" 995 "* ]] && run_cmd "firewall-cmd --permanent --add-service=pop3s" || run_cmd "firewall-cmd --permanent --add-port=995/tcp"
    [[ " ${ports[*]} " == *" 80 "*  ]] && run_cmd "firewall-cmd --permanent --add-service=http"  || run_cmd "firewall-cmd --permanent --add-port=80/tcp"
    run_cmd "firewall-cmd --reload"
    log_info "Firewall: порты открыты через firewalld: ${ports[*]}"
    return
  fi

  log_info "Firewall: UFW/firewalld не активен — действий не требуется"
}

# --- ENTRYPOINT ---
fw::open_ports


##################################################
### FILE: ./install-smtp/modules/100_report.sh
##################################################

#!/usr/bin/env bash
# Module: Final report & manifest (no yq; clean DKIM; no noise)

set -euo pipefail

# Ожидаем, что окружение уже загружено install.sh (DOMAIN, HOSTNAME, IPV4, SELECTOR?, log/run_cmd)
: "${SELECTOR:=s1}"

# --- helpers ---
port_state() {
  local p="$1"
  if ss -ltn "sport = :${p}" 2>/dev/null | grep -q LISTEN; then
    echo "open"
  else
    echo "closed"
  fi
}

# Состояния портов
P25="$(port_state 25)"
P465="$(port_state 465)"
P587="$(port_state 587)"
P993="$(port_state 993)"
P995="$(port_state 995)"

# DMARC по умолчанию (можешь переопределить переменной окружения DMARC_VALUE)
DMARC_VALUE="${DMARC_VALUE:-v=DMARC1; p=none; rua=mailto:dmarc@${DOMAIN}}"

# Чистое значение DKIM
DKIM_VALUE=""
if [[ -f /var/local/msa/dkim.txt ]]; then
  DKIM_VALUE="$(tr -d '\n' </var/local/msa/dkim.txt || true)"
fi
if [[ -z "$DKIM_VALUE" && -f "/etc/opendkim/keys/${DOMAIN}/${SELECTOR}.txt" ]]; then
  # Фоллбэк-парсер из s1.txt (удаляем кавычки/переносы и вытаскиваем содержимое скобок TXT (...))
  DKIM_VALUE="$(sed -e 's/[[:space:]]\+/ /g' -e 's/\"//g' "/etc/opendkim/keys/${DOMAIN}/${SELECTOR}.txt" \
               | tr -d '\n' | sed -E 's/.*TXT \(([^)]*)\).*/\1/' || true)"
fi
[[ -z "$DKIM_VALUE" ]] && DKIM_VALUE="<см. ${SELECTOR}.txt в /etc/opendkim/keys/${DOMAIN}/>"

# --- report.txt ---
run_cmd install -d -m 0755 /var/local/msa
run_cmd install -m 0644 /dev/stdin /var/local/msa/report.txt <<EOF
==== DNS, которые нужно добавить сейчас ====
A     ${HOSTNAME}.                     ${IPV4}
MX    ${DOMAIN}.                       10 ${HOSTNAME}.
TXT   _dmarc.${DOMAIN}.                ${DMARC_VALUE}
TXT   ${SELECTOR}._domainkey.${DOMAIN}.  ${DKIM_VALUE}

[*] PTR/rDNS: у провайдера выставьте PTR для ${IPV4} → ${HOSTNAME}.
EOF
log INFO "Отчёт записан: /var/local/msa/report.txt"

# --- manifest.json (без yq; чистый JSON) ---
run_cmd install -m 0644 /dev/stdin /var/local/msa/manifest.json <<JSON
{
  "hostname": "${HOSTNAME}",
  "ipv4": "${IPV4}",
  "ports": {
    "25":  "${P25}",
    "465": "${P465}",
    "587": "${P587}",
    "993": "${P993}",
    "995": "${P995}"
  },
  "le": { "domain": "${HOSTNAME}" },
  "dns": { "selector": "${SELECTOR}", "DMARC": "${DMARC_VALUE}" },
  "auth": { "users_created": [] },
  "healthcheck": {}
}
JSON
log INFO "manifest.json записан в /var/local/msa/manifest.json"


##################################################
### FILE: ./install-smtp/modules/05_dkim.sh
##################################################

#!/usr/bin/env bash
# Module: OpenDKIM — keys, config, milter, clean TXT export + systemd override

set -euo pipefail
: "${SELECTOR:=s1}"

dkim::prepare_dirs() {
  log INFO "OpenDKIM: подготовка ключей (selector=${SELECTOR}, domain=${DOMAIN})"
  run_cmd install -d -m 0750 -o opendkim -g opendkim "/etc/opendkim/keys/${DOMAIN}"
  run_cmd install -d -m 0750 -o opendkim -g postfix "/var/spool/postfix/opendkim"
}

dkim::ensure_key() {
  local key_priv="/etc/opendkim/keys/${DOMAIN}/${SELECTOR}.private"
  local key_txt="/etc/opendkim/keys/${DOMAIN}/${SELECTOR}.txt"
  if [[ ! -s "$key_priv" || ! -s "$key_txt" ]]; then
    log INFO "OpenDKIM: генерирую 2048-бит ключ (впервые)"
    run_cmd opendkim-genkey -b 2048 -s "${SELECTOR}" -d "${DOMAIN}" -D "/etc/opendkim/keys/${DOMAIN}"
  else
    log INFO "OpenDKIM: ключ уже существует (${SELECTOR} @ ${DOMAIN}) — пропускаю генерацию"
  fi
  run_cmd chown opendkim:opendkim "$key_priv" "$key_txt"
  run_cmd chmod 0600 "$key_priv"
}

dkim::write_tables() {
  log INFO "OpenDKIM: пишу KeyTable/SigningTable/TrustedHosts"
  run_cmd install -D -m 0644 /dev/stdin /etc/opendkim/KeyTable <<EOF
${SELECTOR}._domainkey.${DOMAIN} ${DOMAIN}:${SELECTOR}:/etc/opendkim/keys/${DOMAIN}/${SELECTOR}.private
EOF
  run_cmd install -D -m 0644 /dev/stdin /etc/opendkim/SigningTable <<EOF
*@${DOMAIN} ${SELECTOR}._domainkey.${DOMAIN}
EOF
  run_cmd install -D -m 0644 /dev/stdin /etc/opendkim/TrustedHosts <<EOF
127.0.0.1
localhost
${HOSTNAME}
${IPV4}
EOF
}

dkim::write_config() {
  log INFO "OpenDKIM: пишу конфигурацию (socket=/var/spool/postfix/opendkim/opendkim.sock)"
  run_cmd install -D -m 0644 /dev/stdin /etc/opendkim.conf <<'CONF'
Syslog                  yes
UMask                   002
Mode                    sv
Canonicalization        relaxed/simple
AutoRestart             Yes
AutoRestartRate         10/1h
OversignHeaders         From
SubDomains              yes
UserID                  opendkim:opendkim
KeyTable                /etc/opendkim/KeyTable
SigningTable            /etc/opendkim/SigningTable
ExternalIgnoreList      /etc/opendkim/TrustedHosts
InternalHosts           /etc/opendkim/TrustedHosts
Socket                  local:/var/spool/postfix/opendkim/opendkim.sock
SignatureAlgorithm      rsa-sha256
MinimumKeyBits          1024
CONF
}

dkim::service_override() {
  run_cmd install -d -m 0755 /etc/systemd/system/opendkim.service.d
  run_cmd install -m 0644 /dev/stdin /etc/systemd/system/opendkim.service.d/override.conf <<'EOF'
[Service]
ExecStartPre=/usr/bin/install -d -m0750 -o opendkim -g postfix /var/spool/postfix/opendkim
ExecStartPre=/usr/bin/rm -f /var/spool/postfix/opendkim/opendkim.sock
ExecStart=
ExecStart=/usr/sbin/opendkim -f -x /etc/opendkim.conf -p local:/var/spool/postfix/opendkim/opendkim.sock
Type=simple
EOF
  run_cmd systemctl daemon-reload
}

dkim::enable_service() {
  run_cmd systemctl enable --now opendkim || true
  run_cmd systemctl restart opendkim
}

dkim::attach_milter() {
  local sock="unix:/var/spool/postfix/opendkim/opendkim.sock"
  local cur_smtpd; cur_smtpd="$(postconf -h smtpd_milters || true)"
  local cur_non;   cur_non="$(postconf -h non_smtpd_milters || true)"

  if [[ "${cur_smtpd}" != *"${sock}"* ]]; then
    [[ -n "${cur_smtpd}" ]] && run_cmd postconf -e "smtpd_milters=${cur_smtpd},${sock}" \
                           || run_cmd postconf -e "smtpd_milters=${sock}"
  else
    log INFO "OpenDKIM: smtpd_milters уже содержит ${sock}"
  fi

  if [[ "${cur_non}" != *"${sock}"* ]]; then
    [[ -n "${cur_non}" ]] && run_cmd postconf -e "non_smtpd_milters=${cur_non},${sock}" \
                          || run_cmd postconf -e "non_smtpd_milters=${sock}"
  else
    log INFO "OpenDKIM: non_smtpd_milters уже содержит ${sock}"
  fi

  run_cmd postconf -e "milter_default_action=accept"
  run_cmd postconf -e "milter_protocol=6"
  run_cmd systemctl reload postfix
}

dkim::export_clean_txt() {
  local txt="/etc/opendkim/keys/${DOMAIN}/${SELECTOR}.txt"
  local out="/var/local/msa/dkim.txt"
  run_cmd install -d -m 0755 /var/local/msa

  local value
  value="$(sed -e 's/[[:space:]]\+/ /g' -e 's/\"//g' "$txt" | tr -d '\n' | sed -E 's/.*TXT \(([^)]*)\).*/\1/')" || value=""
  if [[ -n "$value" ]]; then
    printf '%s\n' "$value" | run_cmd install -m 0644 /dev/stdin "$out"
    log INFO "OpenDKIM: чистое значение для DNS записано в $out"
  else
    log WARN "OpenDKIM: не удалось распарсить ${txt} — проверь файл"
  fi
}

# --- run ---
dkim::prepare_dirs
dkim::ensure_key
dkim::write_tables
dkim::write_config
dkim::service_override
dkim::enable_service
dkim::attach_milter
dkim::export_clean_txt


##################################################
### FILE: ./install-smtp/modules/99_healthcheck.sh
##################################################

# modules/99_healthcheck.sh — интеграционные проверки сервисов
# Требует функции: log_info, log_warn, log_error, require_cmd
# Требует переменные: DOMAIN, HOSTNAME, IPV4, VARS_FILE
# Ничего не изменяет, только читает.
# shellcheck shell=bash

healthcheck::require_bins() {
  require_cmd openssl
  # ss предпочтительней; если нет — попробуем lsof; иначе /dev/tcp
  command -v ss >/dev/null 2>&1 || command -v lsof >/dev/null 2>&1 || true
  # dig или host для PTR
  command -v dig >/dev/null 2>&1 || command -v host >/dev/null 2>&1 || true
}

healthcheck::_is_port_listening() {
  # usage: healthcheck::_is_port_listening 587  -> 0/1
  local port="$1"
  if command -v ss >/dev/null 2>&1; then
    ss -ltn | awk '{print $4}' | sed -n 's/.*:\([0-9]\+\)$/\1/p' | grep -qx "$port"
    return $?
  elif command -v lsof >/dev/null 2>&1; then
    lsof -nP -iTCP:"$port" -sTCP:LISTEN >/dev/null 2>&1
    return $?
  else
    # Последний шанс: попытка TCP connect (может зависнуть). Дадим короткий таймаут через bash read.
    # Откроем /dev/tcp и тут же закроем.
    ( exec 3<>"/dev/tcp/127.0.0.1/${port}" ) >/dev/null 2>&1
    return $?
  fi
}

healthcheck::check_ports() {
  log_info "HC: проверяю, что почтовые порты слушаются (25,465,587,993,995)"
  local p
  for p in 25 465 587 993 995; do
    if healthcheck::_is_port_listening "$p"; then
      eval "export PORT_${p}=open"
      log_info "HC: порт ${p} — LISTEN"
    else
      eval "export PORT_${p}=closed"
      log_warn "HC: порт ${p} — НЕ слушается"
    fi
  done
}

# Вспомогательная: выполнить s_client с таймаутом
healthcheck::_s_client() {
  # usage: healthcheck::_s_client args...
  # пытаемся ограничить выполнение; timeout может отсутствовать — тогда без него
  if command -v timeout >/dev/null 2>&1; then
    timeout -k 3 10 openssl s_client "$@"
  else
    openssl s_client "$@"
  fi
}

# Вставь вместо старой функции healthcheck::check_tls
healthcheck::check_tls() {
  log_info "HC: TLS проверки SMTPS(465), IMAPS(993) и STARTTLS на 587"

  _tls_ok() { # host port [starttls_proto]
    local host="$1" port="$2" starttls="${3:-}"
    local out rc
    if [[ -n "$starttls" ]]; then
      out="$(timeout 10s openssl s_client -brief -verify_hostname "$host" -starttls "$starttls" -connect "$host:$port" </dev/null 2>&1 || true)"
    else
      out="$(timeout 10s openssl s_client -brief -verify_hostname "$host" -connect "$host:$port" </dev/null 2>&1 || true)"
    fi
    rc=$?
    # Успех, если:
    # - команда вернулась с кодом 0 И
    # - в выводе есть "Verification: OK" или "Verify return code: 0" И
    # - peername совпал
    if [[ $rc -eq 0 ]] && \
       echo "$out" | grep -Eq 'Verification: OK|Verify return code: 0' && \
       echo "$out" | grep -Fq "Verified peername: $host"; then
      echo "ok"; return 0
    fi
    log_error "HC: ${port} $( [[ -n $starttls ]] && echo SMTP STARTTLS || echo TLS ) — ошибка TLS/hostname. Вывод: $out"
    echo "error"; return 1
  }

  local h="$HOSTNAME"
  export HC_SMTPS_465="$(_tls_ok "$h" 465 || true)"
  export HC_IMAPS_993="$(_tls_ok "$h" 993 || true)"
  export HC_SMTP_587_STARTTLS="$(_tls_ok "$h" 587 smtp || true)"
}


healthcheck::check_rdns_helo() {
  log_info "HC: проверка PTR(rDNS) и баннера Postfix (HELO)"

  # PTR
  local ptr=""
  if command -v dig >/dev/null 2>&1; then
    ptr="$(dig -x "${IPV4}" +short 2>/dev/null | sed -n '1s/\.$//p')"
  elif command -v host >/dev/null 2>&1; then
    ptr="$(host "${IPV4}" 2>/dev/null | awk '/domain name pointer/ {print $5}' | sed 's/\.$//')"
  fi

  if [[ -z "$ptr" ]]; then
    export HC_HELO_MATCHES_PTR="error"
    log_error "HC: PTR для ${IPV4} не найден"
    return
  fi

  if [[ "${ptr}" != "${HOSTNAME}" ]]; then
    export HC_HELO_MATCHES_PTR="error"
    log_error "HC: PTR (${ptr}) != HOSTNAME (${HOSTNAME})"
  else
    # Проверим баннер на 25
    local banner=""
    # /dev/tcp без зависимостей; таймаут чтения 5 сек
    exec 3<>"/dev/tcp/127.0.0.1/25" || {
      export HC_HELO_MATCHES_PTR="error"
      log_error "HC: не удалось подключиться к localhost:25 для чтения баннера"
      return
    }
    # читаем строку баннера
    IFS= read -r -t 5 banner <&3 || true
    printf 'QUIT\r\n' >&3 || true
    exec 3>&- || true
    if grep -q "${HOSTNAME}" <<<"$banner"; then
      export HC_HELO_MATCHES_PTR="ok"
      log_info "HC: SMTP баннер содержит ${HOSTNAME}, PTR совпадает"
    else
      export HC_HELO_MATCHES_PTR="error"
      log_error "HC: SMTP баннер не содержит ${HOSTNAME}. Баннер: ${banner}"
    fi
  fi
}

healthcheck::check_dkim() {
  log_info "HC: проверка DKIM (opendkim-testkey)"
  local selector privkey out rc
  selector="$(yq -r '.dkim_selector // "s1"' "${VARS_FILE}")"
  privkey="/etc/opendkim/keys/${DOMAIN}/${selector}.private"

  if ! command -v opendkim-testkey >/dev/null 2>&1; then
    export HC_DKIM_SIGN="error"
    log_error "HC: отсутствует opendkim-testkey — пропускаю проверку"
    return
  fi
  if [[ ! -r "$privkey" ]]; then
    export HC_DKIM_SIGN="error"
    log_error "HC: приватный ключ DKIM не найден: ${privkey}"
    return
  fi

  # opendkim-testkey вернёт 0, если DNS-запись доступна и корректна
  out="$(opendkim-testkey -d "${DOMAIN}" -s "${selector}" -k "${privkey}" -vv 2>&1)" && rc=0 || rc=$?
  if [[ "$rc" -eq 0 ]]; then
    export HC_DKIM_SIGN="ok"
    log_info "HC: DKIM testkey ok (selector=${selector})"
  else
    export HC_DKIM_SIGN="error"
    log_error "HC: DKIM testkey FAIL (selector=${selector}). Вывод: ${out}"
  fi
}

healthcheck::run_all() {
  healthcheck::require_bins
  healthcheck::check_ports
  healthcheck::check_tls
  healthcheck::check_rdns_helo
  healthcheck::check_dkim
  log_info "HC: проверки завершены"
}

# --- ENTRYPOINT ---
healthcheck::run_all


##################################################
### FILE: ./install-smtp/modules/03_postfix.sh
##################################################

#!/usr/bin/env bash
# Module: Postfix base config + TLS hardening + services (25/465/587)
# Uses env: DOMAIN, HOSTNAME, IPV4, ACCEPT_INBOUND

postfix::write_mailname() {
  if [[ -n "${HOSTNAME:-}" ]]; then
    log INFO "Пишу /etc/mailname = ${HOSTNAME}"
    printf '%s\n' "$HOSTNAME" | run_cmd tee /etc/mailname >/dev/null
  fi
}

postfix::base_config() {
  log INFO "Postfix: базовая конфигурация и TLS-жёсткость (TLS1.2+)"
  run_cmd postconf -e \
    "myhostname=${HOSTNAME}" \
    "myorigin=${DOMAIN}" \
    "inet_interfaces=all" \
    "inet_protocols=ipv4" \
    "smtp_address_preference=ipv4" \
    "smtp_bind_address=${IPV4}" \
    "smtpd_banner=\$myhostname ESMTP" \
    "smtpd_sasl_type=dovecot" \
    "smtpd_sasl_path=private/auth" \
    "smtpd_sasl_auth_enable=yes" \
    "smtpd_recipient_restrictions=permit_mynetworks, permit_sasl_authenticated, reject_unauth_destination" \
    "mynetworks=127.0.0.0/8" \
    "smtpd_tls_auth_only=yes" \
    "smtpd_tls_security_level=may" \
    "smtp_tls_security_level=may" \
    "smtpd_tls_protocols=!SSLv2, !SSLv3, !TLSv1, !TLSv1.1" \
    "smtp_tls_protocols=!SSLv2, !SSLv3, !TLSv1, !TLSv1.1" \
    "tls_preempt_cipherlist=yes" \
    "smtpd_tls_ciphers=high" \
    "smtp_tls_ciphers=high" \
    "smtpd_tls_mandatory_ciphers=high"
}

postfix::virtual_maps() {
  # Карта алиасов для «почтовых ящиков» (минимальная заглушка — чтобы postmap не падал)
  local map=/etc/postfix/virtual_mailbox_maps
  [[ -f "$map" ]] || printf '# filled by installer\n' | run_cmd install -m 0644 /dev/stdin "$map"
  run_cmd postmap "hash:${map}"
  run_cmd postconf -e "virtual_alias_maps=hash:${map}"
}

postfix::services() {
  log INFO "Postfix: настраиваю master.cf для smtp(25), submission(587), smtps(465)"
  # Основной SMTP (25)
  run_cmd postconf -M "smtp/inet=smtp inet n - y - - smtpd"

  # Submission (587) — STARTTLS обязателен
  run_cmd postconf -M "submission/inet=submission inet n - y - - smtpd"
  run_cmd postconf -P "submission/inet/smtpd_tls_security_level=encrypt"
  run_cmd postconf -P "submission/inet/smtpd_sasl_auth_enable=yes"
  run_cmd postconf -P "submission/inet/smtpd_client_restrictions=permit_sasl_authenticated,reject"

  # SMTPS (465) — TLS wrapper
  run_cmd postconf -M "smtps/inet=smtps inet n - y - - smtpd"
  run_cmd postconf -P "smtps/inet/smtpd_tls_wrappermode=yes"
  run_cmd postconf -P "smtps/inet/smtpd_sasl_auth_enable=yes"
  run_cmd postconf -P "smtps/inet/smtpd_client_restrictions=permit_sasl_authenticated,reject"

  # LE-сертификаты (если уже есть — прописываем сразу; если нет, модуль 06_ssl повторно задаст)
  local cert="/etc/letsencrypt/live/${HOSTNAME}/fullchain.pem"
  local key="/etc/letsencrypt/live/${HOSTNAME}/privkey.pem"
  if [[ -s "$cert" && -s "$key" ]]; then
    run_cmd postconf -P "submission/inet/smtpd_tls_cert_file=${cert}"
    run_cmd postconf -P "submission/inet/smtpd_tls_key_file=${key}"
    run_cmd postconf -P "smtps/inet/smtpd_tls_cert_file=${cert}"
    run_cmd postconf -P "smtps/inet/smtpd_tls_key_file=${key}"
  else
    log WARN "Postfix: LE-сертификат отсутствует — активирую TLS позднее (модуль 06_ssl)"
  fi
}

postfix::reload() {
  run_cmd postfix check
  run_cmd systemctl enable --now postfix
  run_cmd bash -c "systemctl reload postfix || systemctl restart postfix"
  # Мини-проверка
  if ss -ltn '( sport = :25 or sport = :465 or sport = :587 )' | grep -q LISTEN; then
    log INFO "Postfix: 25/465/587 — LISTEN"
  fi
}

# --- run ---
postfix::write_mailname
postfix::base_config
postfix::virtual_maps
postfix::services
postfix::reload


##################################################
### FILE: ./install-smtp/modules/04_dovecot.sh
##################################################

# modules/04_dovecot.sh — конфигурация Dovecot (IMAPS/POPS, LMTP, SASL)
# Требует: DOMAIN, HOSTNAME, VARS_FILE, DRY_RUN; функции: run_cmd, log_*, die, require_cmd
# shellcheck shell=bash

set -Eeuo pipefail
IFS=$'\n\t'

dovecot::paths() {
  DC_CONF_DIR="/etc/dovecot"
  DC_CONF_DROPIN="${DC_CONF_DIR}/conf.d/90-msa.conf"
  DC_PASSDB_DIR="${DC_CONF_DIR}/passdb"
  DC_PASSDB_FILE="${DC_PASSDB_DIR}/users"
  VMAIL_HOME="/var/vmail"
  LE_FULL="/etc/letsencrypt/live/${HOSTNAME}/fullchain.pem"
  LE_KEY="/etc/letsencrypt/live/${HOSTNAME}/privkey.pem"
}

dovecot::require_bins() {
  require_cmd doveadm
  require_cmd openssl
}

dovecot::write_passdb() {
  dovecot::paths
  run_cmd "install -d -m 0750 '${DC_PASSDB_DIR}'"
  local tmp; tmp="$(mktemp)"
  local count i login password hash
  count="$(yq -r '(.users // []) | length' "${VARS_FILE}")"
  for (( i=0; i<count; i++ )); do
    login="$(yq -r ".users[${i}].login" "${VARS_FILE}")"
    password="$(yq -r ".users[${i}].password" "${VARS_FILE}")"
    [[ -n "$login" && -n "$password" ]] || continue
    hash="$(doveadm pw -s SHA512-CRYPT -p "${password}")"
    printf '%s:%s\n' "$login" "$hash" >> "$tmp"
  done
  run_cmd "install -m 0640 -o root -g vmail '${tmp}' '${DC_PASSDB_FILE}'"
  rm -f "$tmp"
}

dovecot::ensure_maildirs() {
  dovecot::paths
  local count i login u_local u_domain mdir
  count="$(yq -r '(.users // []) | length' "${VARS_FILE}")"
  for (( i=0; i<count; i++ )); do
    login="$(yq -r ".users[${i}].login" "${VARS_FILE}")"
    [[ -n "$login" ]] || continue
    u_local="${login%@*}"
    u_domain="${login#*@}"
    mdir="${VMAIL_HOME}/${u_domain}/${u_local}/Maildir"
    run_cmd "install -d -m 0700 -o vmail -g vmail '${mdir}'"
  done
}

dovecot::write_conf() {
  dovecot::paths
  local tmp; tmp="$(mktemp)"
  {
    cat <<'EOF'
# Managed by msa-install — DO NOT EDIT
protocols = imap pop3 lmtp
listen = *

# Хранилище
mail_location = maildir:/var/vmail/%d/%n/Maildir
# Нижние границы, фактические uid/gid задаются userdb=static
first_valid_uid = 100
first_valid_gid = 100

namespace inbox {
  inbox = yes
}

# Аутентификация
auth_mechanisms = plain login
disable_plaintext_auth = yes
passdb {
  driver = passwd-file
  args = scheme=SHA512-CRYPT username_format=%u /etc/dovecot/passdb/users
}
userdb {
  driver = static
  args = uid=vmail gid=vmail home=/var/vmail/%d/%n
}

# Сокеты для Postfix
service auth {
  unix_listener /var/spool/postfix/private/auth {
    mode = 0660
    user = postfix
    group = postfix
  }
}
service lmtp {
  unix_listener /var/spool/postfix/private/dovecot-lmtp {
    mode = 0600
    user = postfix
    group = postfix
  }
}
EOF
    if [[ -r "${LE_FULL}" && -r "${LE_KEY}" ]]; then
      cat <<EOF
# TLS
ssl = required
ssl_min_protocol = TLSv1.2
ssl_prefer_server_ciphers = yes
ssl_cert = <${LE_FULL}
ssl_key  = <${LE_KEY}
EOF
    else
      cat <<'EOF'
# TLS будет добавлен после получения LE-сертификата (см. 06_ssl.sh)
# ssl = required
EOF
    fi
  } > "$tmp"

  run_cmd "install -D -m 0644 '${tmp}' '${DC_CONF_DROPIN}'"
  rm -f "$tmp"
}

dovecot::reload_enable() {
  run_cmd "dovecot -n"
  run_cmd "systemctl enable --now dovecot"
  run_cmd "systemctl reload dovecot || systemctl restart dovecot"
}

dovecot::ensure_after_le() {
  dovecot::paths
  if [[ -r "${LE_FULL}" && -r "${LE_KEY}" ]]; then
    log_info "Dovecot: обнаружен LE-сертификат — включаю TLS и запускаю сервисы"
    dovecot::write_conf
    dovecot::reload_enable
  else
    log_warn "Dovecot: LE-сертификат всё ещё отсутствует — пропускаю включение TLS"
  fi
}

# --- ENTRYPOINT ---
dovecot::require_bins
dovecot::write_passdb
dovecot::ensure_maildirs
dovecot::write_conf
if [[ -r "/etc/letsencrypt/live/${HOSTNAME}/fullchain.pem" && -r "/etc/letsencrypt/live/${HOSTNAME}/privkey.pem" ]]; then
  dovecot::reload_enable
else
  log_warn "Dovecot: LE-сертификата нет — сервис не запускаю до получения TLS (ожидаю 06_ssl.sh)"
fi


##################################################
### FILE: ./install-smtp/modules/08_opendmarc.sh
##################################################

# modules/08_opendmarc.sh — OpenDMARC milter
# shellcheck shell=bash
set -Eeuo pipefail
IFS=$'\n\t'

opendmarc::write_conf() {
  local cfg="/etc/opendmarc.conf" tmp; tmp="$(mktemp)"
  cat >"$tmp" <<EOF
# Generated by install-smtp
AuthservID ${HOSTNAME}
TrustedAuthservIDs ${HOSTNAME}
Socket local:/var/spool/postfix/opendmarc/opendmarc.sock
UserID opendmarc
UMask 007
Syslog true
SoftwareHeader true
PidFile /run/opendmarc/opendmarc.pid
RejectFailures false
EOF
  run_cmd install -m 0644 "$tmp" "$cfg"; rm -f "$tmp"
}

opendmarc::prepare_paths() {
  run_cmd install -d -m 0755 -o opendmarc -g opendmarc /run/opendmarc
  run_cmd install -d -m 0750 -o opendmarc -g postfix /var/spool/postfix/opendmarc
}

opendmarc::systemd_override() {
  run_cmd install -d -m 0755 /etc/systemd/system/opendmarc.service.d
  local ovr="/etc/systemd/system/opendmarc.service.d/override.conf" tmp; tmp="$(mktemp)"
  cat >"$tmp" <<'EOF'
[Service]
RuntimeDirectory=opendmarc
RuntimeDirectoryMode=0755
User=opendmarc
Group=opendmarc
ExecStart=
ExecStart=/usr/sbin/opendmarc -c /etc/opendmarc.conf -l
EOF
  run_cmd install -m 0644 "$tmp" "$ovr"; rm -f "$tmp"
  run_cmd systemctl daemon-reload
}

opendmarc::wire_postfix() {
  local want="unix:/var/spool/postfix/opendmarc/opendmarc.sock"
  local cur
  cur="$(postconf -h smtpd_milters || true)"
  [[ "$cur" == *"/opendmarc/opendmarc.sock"* ]] || run_cmd postconf -e "smtpd_milters=${cur:+$cur,}$want"
  cur="$(postconf -h non_smtpd_milters || true)"
  [[ "$cur" == *"/opendmarc/opendmarc.sock"* ]] || run_cmd postconf -e "non_smtpd_milters=${cur:+$cur,}$want"
  run_cmd postconf -e "milter_default_action=accept"
  run_cmd postconf -e "milter_protocol=6"
}

opendmarc::restart() {
  run_cmd systemctl enable --now opendmarc
  run_cmd systemctl restart opendmarc
}

# ENTRYPOINT
log_info "OpenDMARC: настраиваю milter и сервис"
opendmarc::write_conf
opendmarc::prepare_paths
opendmarc::systemd_override
opendmarc::wire_postfix
opendmarc::restart


##################################################
### FILE: ./install-smtp/modules/07_fail2ban.sh
##################################################

#!/usr/bin/env bash
# Module: Fail2ban jails + postfix-sasl filter + disable IPv6 warnings

set -euo pipefail

f2b::write_global_ipv6_off() {
  log INFO "Fail2ban: глобально выключаю IPv6 (allowipv6 = no)"
  run_cmd install -D -m 0644 /dev/stdin /etc/fail2ban/fail2ban.local <<'CONF'
[Definition]
allowipv6 = no
CONF
}

f2b::ensure_filter_postfix_sasl() {
  local f="/etc/fail2ban/filter.d/postfix-sasl.conf"
  if [[ ! -f "$f" ]]; then
    log INFO "Fail2ban: не найден фильтр postfix-sasl.conf — создаю"
    run_cmd install -D -m 0644 /dev/stdin "$f" <<'CONF'
[Definition]
failregex = (?i)postfix/smtpd\[\d+\]:\s+warning:\s+[-\w\.:]+\[<HOST>\]:\s+SASL (?:LOGIN|PLAIN|AUTH) authentication failed: .*
            (?i)authentication failure;.*\bSASL\b.*user=<[^>]*>.*rip=<HOST>
ignoreregex =
CONF
  fi
}

f2b::write_jails() {
  log INFO "Fail2ban: пишу конфиг jails в /etc/fail2ban/jail.d/msa-mail.conf"
  run_cmd install -D -m 0644 /dev/stdin /etc/fail2ban/jail.d/msa-mail.conf <<'CONF'
[DEFAULT]
backend = auto
banaction = ufw
findtime = 10m
maxretry = 5
bantime = 1h
ignoreip = 127.0.0.1/8

[postfix]
enabled = true
filter  = postfix
port    = smtp,submission,465
logpath = /var/log/mail.log

[postfix-sasl]
enabled = true
filter  = postfix-sasl
port    = smtp,submission,465
logpath = /var/log/mail.log

[dovecot]
enabled = true
filter  = dovecot
port    = imap,imaps,pop3,pop3s
logpath = /var/log/mail.log
CONF
}

f2b::reload() {
  log INFO "Fail2ban: включаю сервис и перезагружаю конфигурацию"
  run_cmd systemctl enable --now fail2ban
  run_cmd fail2ban-client reload
}

# --- run ---
f2b::write_global_ipv6_off
f2b::ensure_filter_postfix_sasl
f2b::write_jails
f2b::reload


##################################################
### FILE: ./install-smtp/modules/01_prepare.sh
##################################################

# modules/01_prepare.sh — подготовка системы (пакеты, vmail, IPv6-off)
# shellcheck shell=bash
set -Eeuo pipefail
IFS=$'\n\t'

prepare::system_packages() {
  log_info "Обновляю индекс пакетов и ставлю базовые зависимости"
  run_cmd apt-get update

  # Базовый набор пакетов
  local -a pkgs=(
    postfix
    dovecot-core dovecot-imapd dovecot-pop3d dovecot-lmtpd dovecot-sieve dovecot-managesieved
    opendkim opendkim-tools opendmarc
    fail2ban certbot
    rsyslog ca-certificates curl gnupg
    dnsutils iproute2 lsof
  )

  # Добросим postfix-pcre при наличии в репах
  pkg_available() { apt-cache show "$1" >/dev/null 2>&1; }
  if pkg_available postfix-pcre; then
    pkgs+=(postfix-pcre)
  fi

  log_info "Устанавливаю пакеты (${#pkgs[@]}): ${pkgs[*]}"

  # Жёстко через env → исключаем нюансы run_cmd/IFS
  if ! /usr/bin/env DEBIAN_FRONTEND=noninteractive \
        APT_LISTCHANGES_FRONTEND=none \
        UCF_FORCE_CONFOLD=1 \
        apt-get -y install --no-install-recommends "${pkgs[@]}"; then
    log_warn "Первый apt-get install завершился ошибкой — пробую apt-get -f install и повтор"
    /usr/bin/env DEBIAN_FRONTEND=noninteractive apt-get -f -y install
    /usr/bin/env DEBIAN_FRONTEND=noninteractive \
      APT_LISTCHANGES_FRONTEND=none \
      UCF_FORCE_CONFOLD=1 \
      apt-get -y install --no-install-recommends "${pkgs[@]}"
  fi
}

prepare::create_vmail_user() {
  if ! getent group vmail >/dev/null 2>&1; then
    run_cmd groupadd --system vmail
  fi
  if ! id -u vmail >/dev/null 2>&1; then
    if command -v nologin >/dev/null 2>&1; then
      run_cmd useradd -r -g vmail -d /var/vmail -s /usr/sbin/nologin vmail
    else
      run_cmd useradd -r -g vmail -d /var/vmail -s /bin/false vmail
    fi
  fi
  run_cmd install -d -m 0750 -o vmail -g vmail /var/vmail
}

# Жёстко отключаем IPv6 на уровне ядра — для предсказуемости исходящих
prepare::disable_ipv6() {
  log_info "Отключаю IPv6 на уровне ядра (sysctl)"
  local conf="/etc/sysctl.d/98-msa-disable-ipv6.conf"
  local tmp; tmp="$(mktemp)"
  cat > "$tmp" <<'EOF'
# Disabled by msa-installer to ensure IPv4-only routing
net.ipv6.conf.all.disable_ipv6 = 1
net.ipv6.conf.default.disable_ipv6 = 1
net.ipv6.conf.lo.disable_ipv6 = 1
EOF
  run_cmd install -m 0644 "$tmp" "$conf"
  rm -f "$tmp"
  run_cmd sysctl -p "$conf"
}

# --- ENTRYPOINT ---
prepare::system_packages
prepare::create_vmail_user
prepare::disable_ipv6


##################################################
### FILE: ./install-smtp/modules/09_beget_dns.sh
##################################################

#!/usr/bin/env bash
# 09_beget_dns.sh — авто-деплой DNS в Beget из vars.yaml
# - только vars.yaml (никаких .env)
# - dry-run (--dry-run или dns_update.dry_run)
# - бережные изменения per-FQDN через changeRecords
# - пост-верификация A и MX
# Требует: curl, dig, jq, yq

set -Eeuo pipefail

# ====== ЛОГИ/ТРАП ======
ts(){ date -u +'%Y-%m-%dT%H:%M:%SZ'; }
log(){ echo "[$(ts)] [$1] $2"; }
INFO(){ log INFO "$*"; }
WARN(){ log WARN "$*"; }
ERR(){ log ERROR "$*"; }
trap 'ERR "Ошибка на линии $LINENO: \"$BASH_COMMAND\""; exit 1' ERR

# ====== ПАРАМЕТРЫ И УТИЛИТЫ ======
VARS_FILE="${VARS_FILE:-vars.yaml}"

need_bin(){ command -v "$1" >/dev/null 2>&1; }
APT_UPDATED=0
ensure_bin(){
  local b="$1" pkg="${2:-$1}"
  if ! need_bin "$b"; then
    if command -v apt-get >/dev/null 2>&1; then
      if [[ $APT_UPDATED -eq 0 ]]; then
        INFO "apt-get update…"
        apt-get update -y >/dev/null
        APT_UPDATED=1
      fi
      INFO "Устанавливаю $b"
      apt-get install -y "$pkg" >/dev/null
    else
      ERR "Не найден пакетный менеджер для установки $b"; exit 1
    fi
  fi
  command -v "$b" >/dev/null 2>&1 || { ERR "Не удалось установить $b"; exit 1; }
}

ensure_bin curl curl
ensure_bin dig dnsutils
ensure_bin jq jq
ensure_bin yq yq

# ====== ФЛАГИ CLI ======
CLI_DRYRUN=false
for a in "$@"; do
  case "$a" in
    --dry-run) CLI_DRYRUN=true ;;
    *) ;;
  esac
done

normalize_bool() {
  case "${1:-}" in
    1|true|TRUE|yes|YES|on|ON)  echo true ;;
    0|false|FALSE|no|NO|off|OFF) echo false ;;
    *) echo "${1:-}" ;;
  esac
}

# ====== ЧТЕНИЕ vars.yaml ======
yq_get(){ yq -r "$1 // empty" "$VARS_FILE"; }

DOMAIN="$(yq_get '.domain')"
HOSTNAME="$(yq_get '.hostname')"
IPV4="$(yq_get '.ipv4')"

BEGET_LOGIN="$(yq_get '.beget.login')"
BEGET_TOKEN="$(yq_get '.beget.token')"

# блок dns_update (все опционально)
MSA_STATE_DIR="$(yq_get '.dns_update.msa_state_dir')"
MSA_MANIFEST="$(yq_get '.dns_update.msa_manifest')"
MSA_DKIM_TXT="$(yq_get '.dns_update.msa_dkim_txt')"
TTL_DEFAULT="$(yq_get '.dns_update.ttl_default')"
SPF_POLICY="$(yq_get '.dns_update.spf_policy')"
DNS_DRY_RUN_VAL="$(yq_get '.dns_update.dry_run')"

# значения по умолчанию
[[ -n "${MSA_STATE_DIR:-}" ]] || MSA_STATE_DIR="/var/local/msa"
[[ -n "${MSA_MANIFEST:-}"  ]] || MSA_MANIFEST="$MSA_STATE_DIR/manifest.json"
[[ -n "${MSA_DKIM_TXT:-}"  ]] || MSA_DKIM_TXT="$MSA_STATE_DIR/dkim.txt"
[[ -n "${TTL_DEFAULT:-}"   ]] || TTL_DEFAULT="3600"
[[ -n "${SPF_POLICY:-}"    ]] || SPF_POLICY="warn"

DNS_DRY_RUN="$(normalize_bool "${DNS_DRY_RUN_VAL:-false}")"
# CLI имеет приоритет над vars.yaml
[[ "$CLI_DRYRUN" == "true" ]] && DNS_DRY_RUN=true

# нормализация hostname
[[ -n "$HOSTNAME" ]] || HOSTNAME="mail.$DOMAIN"

# валидация
[[ -n "$DOMAIN"   ]] || { ERR "DOMAIN (domain) не задан в $VARS_FILE"; exit 1; }
[[ -n "$HOSTNAME" ]] || { ERR "HOSTNAME (hostname) не задан в $VARS_FILE"; exit 1; }
[[ -n "$IPV4"     ]] || { ERR "IPV4 (ipv4) не задан в $VARS_FILE"; exit 1; }
[[ -n "$BEGET_LOGIN" && -n "$BEGET_TOKEN" ]] || { ERR "beget.login / beget.token не заданы в $VARS_FILE"; exit 1; }

# ====== МАНИФЕСТ (DKIM/DMARC) ======
jq_safe(){ jq -r "$1 // empty" 2>/dev/null || true; }

DKIM_SELECTOR="$( [ -f "$MSA_MANIFEST" ] && jq_safe '.dns.selector' <"$MSA_MANIFEST" )"
[[ -n "$DKIM_SELECTOR" ]] || DKIM_SELECTOR="$(yq_get '.dkim_selector')"
[[ -n "$DKIM_SELECTOR" ]] || DKIM_SELECTOR="s1"

DKIM_VALUE=""
if [[ -f "$MSA_DKIM_TXT" ]]; then
  # убираем переводы строк
  DKIM_VALUE="$(tr -d '\n' <"$MSA_DKIM_TXT")"
fi

DMARC_VALUE_DEFAULT="v=DMARC1; p=none; rua=mailto:dmarc@$DOMAIN"
if [[ -f "$MSA_MANIFEST" ]]; then
  dm="$(jq_safe '.dns.DMARC' <"$MSA_MANIFEST")"
  [[ -n "$dm" ]] && DMARC_VALUE_DEFAULT="$dm"
fi

# ====== FQDNы и нормализация ======
trimdot(){ local s="${1:-}"; echo "${s%.}"; }
APEX_FQDN="$(trimdot "$DOMAIN")"
MAIL_FQDN="$(trimdot "$HOSTNAME")"
DKIM_FQDN="$(trimdot "${DKIM_SELECTOR}._domainkey.$DOMAIN")"
DMARC_FQDN="$(trimdot "_dmarc.$DOMAIN")"

INFO "Конфиг: domain=$APEX_FQDN, host=$MAIL_FQDN, ip=$IPV4, TTL=$TTL_DEFAULT, SPF_POLICY=$SPF_POLICY, dry-run=$DNS_DRY_RUN"

# ====== ПРОВЕРКА NS (Beget?) ======
ns_list="$(dig NS +short "$APEX_FQDN" | sed 's/\.$//')"
if [[ -z "$ns_list" ]]; then
  WARN "NS для $APEX_FQDN не получены — пропускаю авто-DNS."
  exit 0
fi
if ! echo "$ns_list" | grep -qi 'beget'; then
  WARN "Домен $APEX_FQDN делегирован НЕ на Beget: $(echo "$ns_list" | tr '\n' ' ' | sed 's/ $//')"
  INFO "Пропускаю авто-DNS. Добавьте записи вручную."
  exit 0
fi
INFO "NS у $APEX_FQDN — Beget:"
echo "$ns_list" | sed 's/^/  - /'

# ====== Beget API ======
beget_api_post(){
  local path="$1" json="$2"
  curl -fsS --connect-timeout 15 --max-time 45 \
    -X POST "https://api.beget.com/api/dns/$path" \
    -d "login=$BEGET_LOGIN" \
    -d "token=$BEGET_TOKEN" \
    -d "input_format=json" \
    -d "output_format=json" \
    --data-urlencode "input_data=$json"
}

api_ok(){ jq -e '.status=="success" and ((.answer.status//"success")=="success")' >/dev/null 2>&1; }
api_errmsg(){ jq -r '.answer.errors? // .error? // .answer.error_text? // .error_text? // .result.message? // "unknown error"' 2>/dev/null; }

dns_get(){
  local fqdn="$1"
  beget_api_post "getData" "$(jq -c --null-input --arg f "$fqdn" '{fqdn:$f}')" 
}

dns_change(){
  local fqdn="$1" records_json="$2"
  beget_api_post "changeRecords" "$(jq -c --arg f "$fqdn" --argjson r "$records_json" '{fqdn:$f,records:$r}')" 
}

sanitize_records(){
  jq -c 'if . == null then {} else
           with_entries(select(.key|IN("A","AAAA","CNAME","MX","TXT","SRV","CAA")))
         end'
}

read_recset(){
  local fqdn="$1" resp
  resp="$(dns_get "$fqdn")"
  if [[ -z "$resp" ]]; then
    ERR "[$fqdn] пустой ответ от Beget API"; exit 1
  fi
  if ! echo "$resp" | api_ok; then
    ERR "[$fqdn] Beget API error: $(echo "$resp" | api_errmsg)"; exit 1
  fi
  echo "$resp" | jq -c '.answer.result.records // {}' | sanitize_records
}

# ====== SPF ======
extract_spf(){
  jq -r '(.TXT // []) | map(.value // .txtdata) | map(sub("^\"|\"$";"")) | map(select(test("^\\s*v=spf1\\b"; "i"))) | .[0] // empty'
}

update_spf(){
  local recset="$1" policy="$2" host="$3" ttl="$4"
  local cur_spf new_spf
  cur_spf="$(echo "$recset" | extract_spf || true)"

  if [[ "$policy" == "warn" && -n "$cur_spf" ]]; then
    # не трогаем существующий SPF
    echo "$recset"
    return
  fi

  if [[ -z "$cur_spf" ]]; then
    new_spf="v=spf1 mx a:${host} ~all"
  else
    new_spf="$cur_spf"
    if ! grep -qiE "(^|[[:space:]])a:${host}([[:space:]]|$)" <<<"$new_spf"; then
      if grep -qiE '[[:space:]][~\-\?+]?all([[:space:]]|$)' <<<"$new_spf"; then
        new_spf="$(sed -E "s/[[:space:]]([~\\-\\?\\+]?all)([[:space:]]|$)/ a:${host} \\1\\2/I" <<<"$new_spf")"
      else
        new_spf="$new_spf a:${host}"
      fi
    fi
  fi

  jq -c --arg v "$new_spf" --argjson t "$ttl" '
    .TXT = ((.TXT // []) | map(select((.value // .txtdata) | test("^\\s*v=spf1\\b"; "i") | not)) + [{value:$v,ttl:$t}])
  ' <<<"$recset"
}

# ====== СБОРКА ЦЕЛЕВЫХ СЕТОВ ======
build_mail_recset(){
  local cur="$1" ip="$2" ttl="$3"
  jq -c --arg ip "$ip" --argjson t "$ttl" '
    .A = [{value:$ip, ttl:$t}] | del(.CNAME)
  ' <<<"$cur"
}

build_apex_recset(){
  local cur="$1" mailfq="$2" ttl="$3" spfpol="$4"
  local mxv="10 ${mailfq}."
  cur="$(jq -c --arg v "$mxv" --argjson t "$ttl" '.MX = [{value:$v, ttl:$t}]' <<<"$cur")"
  cur="$(update_spf "$cur" "$spfpol" "$mailfq" "$ttl")"
  echo "$cur"
}

build_dkim_recset(){
  local cur="$1" dkim="$2" ttl="$3"
  jq -c --arg v "$dkim" --argjson t "$ttl" '.TXT = [{value:$v, ttl:$t}]' <<<"$cur"
}

build_dmarc_recset(){
  local cur="$1" dmarc="$2" ttl="$3"
  # Добавляем TXT только если на _dmarc записи нет
  if [[ "$(jq -r '.TXT | length // 0' <<<"$cur")" -gt 0 ]]; then
    echo "$cur"
  else
    jq -c --arg v "$dmarc" --argjson t "$ttl" '.TXT = [{value:$v, ttl:$t}]' <<<"$cur"
  fi
}

# ====== ПРИМЕНЕНИЕ (per-FQDN changeRecords) ======
apply_recset(){
  local fqdn="$1" before="$2" after="$3"
  local b_norm a_norm
  b_norm="$(jq -S <<<"$before")"
  a_norm="$(jq -S <<<"$after")"

  if [[ "$b_norm" == "$a_norm" ]]; then
    INFO "[$fqdn] изменений нет"
    return 0
  fi

  if [[ "$DNS_DRY_RUN" == "true" ]]; then
    INFO "[$fqdn] DRY-RUN: изменения:"
    diff -u <(echo "$b_norm") <(echo "$a_norm") || true
    return 0
  fi

  INFO "[$fqdn] changeRecords…"
  local resp; resp="$(dns_change "$fqdn" "$after")"
  if [[ -z "$resp" ]] || ! echo "$resp" | api_ok; then
    ERR "[$fqdn] ошибка changeRecords: $(echo "$resp" | api_errmsg)"
    exit 1
  fi
}

# ====== ПЛАН/ПРИМЕНЕНИЕ ======
INFO "Читаю текущие записи…"
cur_mail="$(read_recset "$MAIL_FQDN")"
cur_apex="$(read_recset "$APEX_FQDN")"
cur_dkim="$(read_recset "$DKIM_FQDN")"
cur_dmarc="$(read_recset "$DMARC_FQDN")"

new_mail="$(build_mail_recset  "$cur_mail"  "$IPV4"                   "$TTL_DEFAULT")"
new_apex="$(build_apex_recset  "$cur_apex"  "$MAIL_FQDN"              "$TTL_DEFAULT" "$SPF_POLICY")"

if [[ -n "$DKIM_VALUE" ]]; then
  new_dkim="$(build_dkim_recset "$cur_dkim" "$DKIM_VALUE"             "$TTL_DEFAULT")"
else
  new_dkim="$cur_dkim"
  WARN "DKIM-файл не найден ($MSA_DKIM_TXT) — пропускаю DKIM."
fi

new_dmarc="$(build_dmarc_recset "$cur_dmarc" "$DMARC_VALUE_DEFAULT"   "$TTL_DEFAULT")"

apply_recset "$MAIL_FQDN"  "$cur_mail"  "$new_mail"
apply_recset "$APEX_FQDN"  "$cur_apex"  "$new_apex"
[[ -n "$DKIM_VALUE" ]] && apply_recset "$DKIM_FQDN" "$cur_dkim" "$new_dkim"
apply_recset "$DMARC_FQDN" "$cur_dmarc" "$new_dmarc"

# ====== ВЕРИФИКАЦИЯ ======
INFO "Верификация после применения…"
verify(){
  local fqdn="$1" filter="$2"
  local r; r="$(dns_get "$fqdn")"
  if ! echo "$r" | api_ok; then
    echo "fail"; return
  fi
  echo "$r" | jq -re "$filter" >/dev/null 2>&1 && echo "ok" || echo "fail"
}

vA="$(verify "$MAIL_FQDN"  --arg ip "$IPV4" '.answer.result.records.A[]?  | select((.value // .address) == $ip)')"
vMX="$(verify "$APEX_FQDN" --arg m "10 ${MAIL_FQDN}." '.answer.result.records.MX[]? | select((.value // (.preference|tostring+" "+.exchange)) == $m)')"

INFO "Итог: A($MAIL_FQDN)=$vA, MX($APEX_FQDN)=$vMX"
INFO "Готово."
exit 0


